// Generated by CoffeeScript 1.6.3
module.exports.create = function(port, secret) {
  var viewport;
  viewport = {
    controller: function(opts, callback) {
      return callback(null, {
        headers: {
          'Content-Type': 'text/javascript'
        },
        body: "(" + (module.exports.browserClient.toString()) + ").call(self, '" + port + "', '" + secret + "', '" + opts.query.name + "');"
      });
    },
    view: function(opts, callback) {
      var name;
      name = opts.query.name || 'Untitled';
      return callback(null, {
        headers: {
          'Content-Type': 'text/html'
        },
        body: "<body>\n<script src=\"/build.js\"></script>\n<script src=\"./controller?name=" + name + "\"></script>\n</body>"
      });
    }
  };
  viewport.controller.$www = {};
  viewport.view.$www = {};
  return viewport;
};

module.exports.browserClient = function(port, secret, name) {
  var THREE, animate, aspect, camera, client, container, dom, far, fov, height, near, pointLight, radius, renderer, rings, scene, segments, sphere, sphereGeometry, sphereMaterial, width, x;
  client = require('vertex-client').create({
    uuid: name,
    context: {
      name: name
    },
    secret: secret,
    connect: {
      uri: "ws://localhost:" + port
    }
  });
  client.connect();
  dom = require('dom');
  THREE = require('three');
  container = dom('body').append('<div></div>');
  width = 400;
  height = 300;
  fov = 45;
  aspect = width / height;
  near = 0.1;
  far = 1000;
  renderer = new THREE.WebGLRenderer;
  camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
  scene = new THREE.Scene;
  scene.add(camera);
  camera.position.z = 300;
  renderer.setSize(width, height);
  renderer.setClearColor(0x222222, 1);
  container.append(renderer.domElement);
  radius = 50;
  segments = 16;
  rings = 16;
  sphereGeometry = new THREE.SphereGeometry(radius, segments, rings);
  sphereMaterial = new THREE.MeshLambertMaterial({
    color: 0xCC0D0E
  });
  sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
  scene.add(sphere);
  pointLight = new THREE.PointLight(0xFFFFFF);
  pointLight.position.x = 10;
  pointLight.position.y = 50;
  pointLight.position.z = 130;
  scene.add(pointLight);
  x = 0;
  animate = function() {
    try {
      requestAnimationFrame(animate);
      sphere.position.x = 100 * Math.cos(x++ / 10);
      sphere.position.y = 50 * Math.sin(x / 5);
      return renderer.render(scene, camera);
    } catch (_error) {}
  };
  return animate();
};
